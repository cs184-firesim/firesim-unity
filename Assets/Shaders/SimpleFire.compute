// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

RWTexture3D<float4> velocityTex;
RWTexture3D<float4> velocityTexRes;
RWTexture3D<float> pressureTex;
RWTexture3D<float> pressureTexRes;
RWTexture3D<float> temperatureTex;
RWTexture3D<float> temperatureTexRes;
RWTexture3D<float> densityTex;
RWTexture3D<float> densityTexRes;
RWTexture3D<float> divergenceTex;
RWTexture3D<float> debugTex;
int size;

// timeStep of simulation

float timeStep;

// SamplerState samplervelocityTex;

float3 cellIndex2TexCoord(float3 index)
{
    // Convert a value in the range [0,gridSize] to one in the range [0,1].
    return float3(index.x / size,
    index.y / size,
    (index.z+0.5) / size);
}


#pragma kernel InitFire

[numthreads(8,8,8)]
void InitFire (uint3 id : SV_DispatchThreadID) {
    float3 v = id;

    // half sphere

    float RADIUS = 16;
    uint two = 2;
    float half_size = size / two;
    float dx = v.x - half_size;
    float dy = v.y;
    float dz = v.z - half_size;
    float from_center = sqrt(dx * dx + dz * dz);

    float4 dist_vec = float4(dx, dy, dz, 0);


    if (from_center > RADIUS || id.y > 0) return;

    
    velocityTexRes[id] = float4(0,0.5,0,0);
    
   
    //velocityTexRes[id.xyz] = dist_vec;
    densityTexRes[id] = 1.0;
    temperatureTexRes[id] = 10.0 + from_center;
    
    //if (velocityTexRes[id].y > 0.5) debugTex[id] = 1.0f;


}

#pragma kernel ApplyBuoyancy

[numthreads(8,8,8)]
void ApplyBuoyancy (uint3 id : SV_DispatchThreadID) {
    float3 v = id;
    float SIGMA = 1.0;
    float KAPPA = 0.2;
    float T0 = 5.0;

    float temperature = temperatureTex[id];

    // do an offset by room temperature
    temperature += T0;

    float density = densityTex[id];

    float4 change = float4(0.0,  - KAPPA * density + SIGMA * (( 1.0 / T0 ) - ( 1.0 / temperature )) , 0.0, 0.0);

    velocityTexRes[v] += change;

}

#pragma kernel Advection

[numthreads(8,8,8)]
void Advection (uint3 id : SV_DispatchThreadID)
{
    float3 v = id;
    float3 cellVelocity = velocityTex[id].xyz;

    
    float3 pos = v - cellVelocity * timeStep;


    // pos = cellIndex2TexCoord(pos);
    
    // if (velocityTex[id].x > 0.1) debugTex[id] = 1.0f;
    // velocityTexRes[id] = velocityTex.SampleLevel(samplervelocityTex, pos, 0);


    float eps = 0.00001;

    // My own lerp
    // boundary conditions

    pos.xyz = abs(pos.xyz);
    if (pos.x > size - 1) pos.x = 2 * size - 2 - pos.x;
    if (pos.y > size - 1) pos.y = 2 * size - 2 - pos.y;
    if (pos.z > size - 1) pos.z = 2 * size - 2 - pos.z;

    // lerp
    uint lx = floor(pos.x); uint hx = ceil(pos.x + eps);
    uint ly = floor(pos.y); uint hy = ceil(pos.y + eps);
    uint lz = floor(pos.z); uint hz = ceil(pos.z + eps);
    float lxd = pos.x - lx; float hxd = hx - pos.x;
    float lyd = pos.y - ly; float hyd = hy - pos.y;
    float lzd = pos.z - lz; float hzd = hz - pos.z;

    velocityTexRes[id] = velocityTex[uint3(lx, ly, lz)]*hxd*hyd*hzd +
        velocityTex[uint3(hx, ly, lz)]*lxd*hyd*hzd +
        velocityTex[uint3(lx, hy, lz)]*hxd*lyd*hzd +
        velocityTex[uint3(hx, hy, lz)]*lxd*lyd*hzd +
        velocityTex[uint3(lx, ly, hz)]*hxd*hyd*lzd +
        velocityTex[uint3(hx, ly, hz)]*lxd*hyd*lzd +
        velocityTex[uint3(lx, hy, hz)]*hxd*lyd*lzd +
        velocityTex[uint3(hx, hy, hz)]*lxd*lyd*lzd;



    densityTexRes[id] = 0.99*(densityTex[uint3(lx, ly, lz)]*hxd*hyd*hzd +
        densityTex[uint3(hx, ly, lz)]*lxd*hyd*hzd +
        densityTex[uint3(lx, hy, lz)]*hxd*lyd*hzd +
        densityTex[uint3(hx, hy, lz)]*lxd*lyd*hzd +
        densityTex[uint3(lx, ly, hz)]*hxd*hyd*lzd +
        densityTex[uint3(hx, ly, hz)]*lxd*hyd*lzd +
        densityTex[uint3(lx, hy, hz)]*hxd*lyd*lzd +
        densityTex[uint3(hx, hy, hz)]*lxd*lyd*lzd);


    temperatureTexRes[id] = (temperatureTex[uint3(lx, ly, lz)]*hxd*hyd*hzd +
        temperatureTex[uint3(hx, ly, lz)]*lxd*hyd*hzd +
        temperatureTex[uint3(lx, hy, lz)]*hxd*lyd*hzd +
        temperatureTex[uint3(hx, hy, lz)]*lxd*lyd*hzd +
        temperatureTex[uint3(lx, ly, hz)]*hxd*hyd*lzd +
        temperatureTex[uint3(hx, ly, hz)]*lxd*hyd*lzd +
        temperatureTex[uint3(lx, hy, hz)]*hxd*lyd*lzd +
        temperatureTex[uint3(hx, hy, hz)]*lxd*lyd*lzd);

/*
    if (
        (densityTex[uint3(hx, ly, lz)] >= 0.01 ||
        densityTex[uint3(lx, ly, lz)] >= 0.01 ||
        densityTex[uint3(lx, hy, lz)] >= 0.01 ||
        densityTex[uint3(hx, hy, lz)] >= 0.01 ||
        densityTex[uint3(lx, ly, hz)] >= 0.01 ||
        densityTex[uint3(hx, ly, hz)] >= 0.01 ||
        densityTex[uint3(lx, hy, hz)] >= 0.01 ||
        densityTex[uint3(hx, hy, hz)] >= 0.01) && densityTex[id] <= 0.0001 ) {
        debugTex[id] = 1.0f;
        // debugTex[uint3(hx, ly, lz)] = 1.0f;
        // debugTex[uint3(lx, hy, lz)] = 1.0f;
        // debugTex[uint3(hx, hy, lz)] = 1.0f;
        // debugTex[uint3(lx, ly, hz)] = 1.0f;
        // debugTex[uint3(hx, ly, hz)] = 1.0f;
        // debugTex[uint3(lx, hy, hz)] = 1.0f;
        // debugTex[uint3(hx, hy, hz)] = 1.0f;

    }
       */
}

#pragma kernel Divergence

[numthreads(8,8,8)]
void Divergence (uint3 id : SV_DispatchThreadID)
{
    uint size_ = uint(size);
    uint3 v = id;



    

    float4 fieldL = float4(0.0, 0.0, 0.0, 0.0);
    float4 fieldR = float4(0.0, 0.0, 0.0, 0.0);
    float4 fieldB = float4(0.0, 0.0, 0.0, 0.0);
    float4 fieldT = float4(0.0, 0.0, 0.0, 0.0);
    float4 fieldD = float4(0.0, 0.0, 0.0, 0.0);
    float4 fieldU = float4(0.0, 0.0, 0.0, 0.0);

    if (v.x > 0) fieldL = velocityTex[uint3(v.x-1, v.y, v.z)];
    if (v.y > 0) fieldB = velocityTex[uint3(v.x, v.y-1, v.z)];
    if (v.z > 0) fieldD = velocityTex[uint3(v.x, v.y, v.z-1)];
    if (v.x < size_-1) fieldR = velocityTex[uint3(v.x+1, v.y, v.z)];
    if (v.y < size_-1) fieldT = velocityTex[uint3(v.x, v.y+1, v.z)];
    if (v.z < size_-1) fieldU = velocityTex[uint3(v.x, v.y, v.z+1)];

    float divergence = 0.5 * ((fieldR.x - fieldL.x) + (fieldT.y - fieldB.y) + (fieldU.z - fieldD.z));

    divergenceTex[id] = divergence;
    
}

#pragma kernel Jacobi

[numthreads(8,8,8)]
void Jacobi (uint3 id : SV_DispatchThreadID)
{
    uint size_ = uint(size);
    float3 v = id;

    float dC = divergenceTex[id];
    float pC = pressureTex[id];

    float pL = (id.x > 0) ? pressureTex[uint3(id.x-1, id.y, id.z)] : pC;
    float pR = (id.x < size_-1) ? pressureTex[uint3(id.x+1, id.y, id.z)] : pC;
    float pB = (id.y > 0) ? pressureTex[uint3(id.x, id.y-1, id.z)] : pC;
    float pT = (id.y < size_-1) ? pressureTex[uint3(id.x, id.y+1, id.z)] : pC;
    float pD = (id.z > 0) ? pressureTex[uint3(id.x, id.y, id.z-1)] : pC;
    float pU = (id.z < size_-1) ? pressureTex[uint3(id.x, id.y, id.z+1)] : pC;

    pressureTexRes[id] = (pL + pR + pB + pT + pU + pD - dC)/6.0;

}

/*
void JacobiFunc (uint3 id : SV_DispatchThreadID, int i)
{
    uint size_ = uint(size);

    float dC = divergenceTex[id];
    

    if (i %2 == 0) {
        float pC = pressureTex[id];
        float pL = (id.x > 0) ? pressureTex[uint3(id.x-1, id.y, id.z)] : pC;
        float pR = (id.x < size_-1) ? pressureTex[uint3(id.x+1, id.y, id.z)] : pC;
        float pB = (id.y > 0) ? pressureTex[uint3(id.x, id.y-1, id.z)] : pC;
        float pT = (id.y < size_-1) ? pressureTex[uint3(id.x, id.y+1, id.z)] : pC;
        float pD = (id.z > 0) ? pressureTex[uint3(id.x, id.y, id.z-1)] : pC;
        float pU = (id.z < size_-1) ? pressureTex[uint3(id.x, id.y, id.z+1)] : pC;

        pressureTexRes[id] = (pL + pR + pB + pT + pU + pD - dC)/6.0;
    }
    else {
        float pC = pressureTexRes[id];
        float pL = (id.x > 0) ? pressureTexRes[uint3(id.x-1, id.y, id.z)] : pC;
        float pR = (id.x < size_-1) ? pressureTexRes[uint3(id.x+1, id.y, id.z)] : pC;
        float pB = (id.y > 0) ? pressureTexRes[uint3(id.x, id.y-1, id.z)] : pC;
        float pT = (id.y < size_-1) ? pressureTexRes[uint3(id.x, id.y+1, id.z)] : pC;
        float pD = (id.z > 0) ? pressureTexRes[uint3(id.x, id.y, id.z-1)] : pC;
        float pU = (id.z < size_-1) ? pressureTexRes[uint3(id.x, id.y, id.z+1)] : pC;

        pressureTex[id] = (pL + pR + pB + pT + pU + pD - dC)/6.0;


    }

}
*/


#pragma kernel Projection

[numthreads(8,8,8)]
void Projection (uint3 id : SV_DispatchThreadID)
{
    float3 v = id;
    uint size_ = uint(size);

    // TODO: case where id is in some object

    float pC = pressureTex[v];
    float pL = (id.x > 0) ? pressureTex[uint3(id.x-1, id.y, id.z)] : pC;
    float pR = (id.x < size_-1) ? pressureTex[uint3(id.x+1, id.y, id.z)] : pC;
    float pB = (id.y > 0) ? pressureTex[uint3(id.x, id.y-1, id.z)] : pC;
    float pT = (id.y < size_-1) ? pressureTex[uint3(id.x, id.y+1, id.z)] : pC;
    float pD = (id.z > 0) ? pressureTex[uint3(id.x, id.y, id.z-1)] : pC;
    float pU = (id.z < size_-1) ? pressureTex[uint3(id.x, id.y, id.z+1)] : pC;


    float4 gradP = 0.5*float4(pR - pL, pT - pB, pU - pD, 0.0); float4 vOld = velocityTex[id]; float4 vNew = vOld - gradP; velocityTexRes[id] = vNew;

    /*
    


    float3 vL = float3(0.0, 0.0, 0.0); //GetObstacleVelocity(in.LEFTCELL);
    float3 vR = float3(0.0, 0.0, 0.0); //GetObstacleVelocity(in.RIGHTCELL);
    float3 vB = float3(0.0, 0.0, 0.0); //GetObstacleVelocity(in.BOTTOMCELL);
    float3 vT = float3(0.0, 0.0, 0.0); //GetObstacleVelocity(in.TOPCELL);
    float3 vD = float3(0.0, 0.0, 0.0); //GetObstacleVelocity(in.DOWNCELL);
    float3 vU = float3(0.0, 0.0, 0.0); //GetObstacleVelocity(in.UPCELL);


    float4 obstV = float4(0,0,0,0);
    float4 vMask = float4(1,1,1,0);

    if (v.x <= 0) {obstV.x = vL.x; vMask.x = 0; }
    if (v.x >= size-1) {obstV.x = vR.x; vMask.x = 0; }
    if (v.y <= 0) {obstV.y = vB.y; vMask.y = 0; }
    if (v.y >= size-1) {obstV.y = vT.y; vMask.y = 0; }
    if (v.z <= 0) {obstV.z = vD.z; vMask.z = 0; }
    if (v.z >= size-1) {obstV.z = vU.z; vMask.z = 0; }

    // Compute the gradient of pressure at the current cell by
    // taking central differences of neighboring pressure values.
    float4 gradP = 0.5*float4(pR - pL, pT - pB, pU - pD, 0.0);

    // Project the velocity onto its divergence-free component by
    // subtracting the gradient of pressure.
    float4 vOld = velocityTex[v];
    float4 vNew = vOld - gradP;

    // Explicitly enforce the free-slip boundary condition by
    // replacing the appropriate components of the new velocity with
    // obstacle velocities.
    vNew = (vMask * vNew) + obstV;

    velocityTexRes[id] = vNew;
    //if (pC == 0)
    //    velocityTexRes[id] = float4(pC, pC, 1.0, 0);
    //else{
    //    velocityTexRes[id] = float4(0.0, max(1, pC*100), 0.0, 0);
    //}

    //Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);







    */
}

#pragma kernel Clear
[numthreads(8,8,8)]
void Clear (uint3 id : SV_DispatchThreadID) {
    velocityTex[id] = float4(0, 0, 0, 0);
    velocityTexRes[id] = float4(0, 0, 0, 0);
    pressureTex[id] = 0;
    pressureTexRes[id] = 0;
    temperatureTex[id] = 0;
    temperatureTexRes[id] = 0;
    densityTex[id] = 0;
    densityTexRes[id] = 0;

}

// Need a second kernel because only 8 writes are allowed per kernel
#pragma kernel Clear2
[numthreads(8,8,8)]
void Clear2 (uint3 id : SV_DispatchThreadID) {
    divergenceTex[id] = 0;
}


#pragma kernel Everything
[numthreads(8,8,8)]
void Everything (uint3 id : SV_DispatchThreadID)
{
    
    //Advection
    

    float3 v = id;
    float3 cellVelocity = velocityTex[id].xyz;

      

    float3 pos = v - cellVelocity * timeStep;
    //float3 pos = v - float3(0, 0.5, 0);

    

    pos.xyz = abs(pos.xyz);
    if (pos.x > size - 1) pos.x = 2 * size - 2 - pos.x;
    if (pos.y > size - 1) pos.y = 2 * size - 2 - pos.y;
    if (pos.z > size - 1) pos.z = 2 * size - 2 - pos.z;

    float eps = 0.00001;

    // lerp
    uint lx = uint(floor(pos.x)); uint hx = uint(ceil(pos.x+eps));
    uint ly = uint(floor(pos.y)); uint hy = uint(ceil(pos.y+eps));
    uint lz = uint(floor(pos.z)); uint hz = uint(ceil(pos.z+eps));
    float lxd = pos.x - lx; float hxd = hx - pos.x;
    float lyd = pos.y - ly; float hyd = hy - pos.y;
    float lzd = pos.z - lz; float hzd = hz - pos.z;

    float4 velocity = velocityTex[uint3(lx, ly, lz)]*hxd*hyd*hzd +
        velocityTex[uint3(hx, ly, lz)]*lxd*hyd*hzd +
        velocityTex[uint3(lx, hy, lz)]*hxd*lyd*hzd +
        velocityTex[uint3(hx, hy, lz)]*lxd*lyd*hzd +
        velocityTex[uint3(lx, ly, hz)]*hxd*hyd*lzd +
        velocityTex[uint3(hx, ly, hz)]*lxd*hyd*lzd +
        velocityTex[uint3(lx, hy, hz)]*hxd*lyd*lzd +
        velocityTex[uint3(hx, hy, hz)]*lxd*lyd*lzd;



    float density = densityTex[uint3(lx, ly, lz)]*hxd*hyd*hzd +
        densityTex[uint3(hx, ly, lz)]*lxd*hyd*hzd +
        densityTex[uint3(lx, hy, lz)]*hxd*lyd*hzd +
        densityTex[uint3(hx, hy, lz)]*lxd*lyd*hzd +
        densityTex[uint3(lx, ly, hz)]*hxd*hyd*lzd +
        densityTex[uint3(hx, ly, hz)]*lxd*hyd*lzd +
        densityTex[uint3(lx, hy, hz)]*hxd*lyd*lzd +
        densityTex[uint3(hx, hy, hz)]*lxd*lyd*lzd;


      if (cellVelocity.y > 0.1 && timeStep == 0 && densityTex[uint3(lx, ly, lz)] == 0 && id.y==1) {debugTex[id] = 1.0;}

    float temperature = temperatureTex[uint3(lx, ly, lz)]*hxd*hyd*hzd +
        temperatureTex[uint3(hx, ly, lz)]*lxd*hyd*hzd +
        temperatureTex[uint3(lx, hy, lz)]*hxd*lyd*hzd +
        temperatureTex[uint3(hx, hy, lz)]*lxd*lyd*hzd +
        temperatureTex[uint3(lx, ly, hz)]*hxd*hyd*lzd +
        temperatureTex[uint3(hx, ly, hz)]*lxd*hyd*lzd +
        temperatureTex[uint3(lx, hy, hz)]*hxd*lyd*lzd +
        temperatureTex[uint3(hx, hy, hz)]*lxd*lyd*lzd;

    AllMemoryBarrier();

    // InitFire
    

    float RADIUS = 16;
    uint two = 2;
    float half_size = size / two;
    float dx = abs(id.x - half_size);
    float dy = id.y;
    float dz = abs(id.z - half_size);
    float from_center = sqrt(dx * dx + dz * dz);

    float4 dist_vec = float4(dx, dy, dz, 0);


    if (from_center <= RADIUS && id.y == 0) {
        velocity = float4(0,1,0,0);
        density = 1.0;
        
        temperature = 20.0 * (RADIUS-from_center) / RADIUS ;
    }

    
   
    
    AllMemoryBarrier();

    // Divergence

    
    uint size_ = uint(size);
    
    
    float4 fieldL = float4(0.0, 0.0, 0.0, 0.0);
    float4 fieldR = float4(0.0, 0.0, 0.0, 0.0);
    float4 fieldB = float4(0.0, 0.0, 0.0, 0.0);
    float4 fieldT = float4(0.0, 0.0, 0.0, 0.0);
    float4 fieldD = float4(0.0, 0.0, 0.0, 0.0);
    float4 fieldU = float4(0.0, 0.0, 0.0, 0.0);

    if (id.x > 0) fieldL = velocityTex[uint3(id.x-1, id.y, id.z)];
    if (id.y > 0) fieldB = velocityTex[uint3(id.x, id.y-1, id.z)];
    if (id.z > 0) fieldD = velocityTex[uint3(id.x, id.y, id.z-1)];
    if (id.x < size_-1) fieldR = velocityTex[uint3(id.x+1, id.y, id.z)];
    if (id.y < size_-1) fieldT = velocityTex[uint3(id.x, id.y+1, id.z)];
    if (id.z < size_-1) fieldU = velocityTex[uint3(id.x, id.y, id.z+1)];



    float dC = 0.5 * ((fieldR.x - fieldL.x) + (fieldT.y - fieldB.y) + (fieldU.z - fieldD.z));

    
    

    // Jacobi

    float pressure = pressureTex[id];

    for (int i_=0;i_<20;++i_) {

            float pC = pressure;
            float pL = (id.x > 0) ? pressureTex[uint3(id.x-1, id.y, id.z)] : pC;
            float pR = (id.x < size_-1) ? pressureTex[uint3(id.x+1, id.y, id.z)] : pC;
            float pB = (id.y > 0) ? pressureTex[uint3(id.x, id.y-1, id.z)] : pC;
            float pT = (id.y < size_-1) ? pressureTex[uint3(id.x, id.y+1, id.z)] : pC;
            float pD = (id.z > 0) ? pressureTex[uint3(id.x, id.y, id.z-1)] : pC;
            float pU = (id.z < size_-1) ? pressureTex[uint3(id.x, id.y, id.z+1)] : pC;

            pressure = (pL + pR + pB + pT + pU + pD - dC)/6.0;
    }

    // Projection

    float pC = pressure;
    float pL = (id.x > 0) ? pressureTex[uint3(id.x-1, id.y, id.z)] : pC;
    float pR = (id.x < size_-1) ? pressureTex[uint3(id.x+1, id.y, id.z)] : pC;
    float pB = (id.y > 0) ? pressureTex[uint3(id.x, id.y-1, id.z)] : pC;
    float pT = (id.y < size_-1) ? pressureTex[uint3(id.x, id.y+1, id.z)] : pC;
    float pD = (id.z > 0) ? pressureTex[uint3(id.x, id.y, id.z-1)] : pC;
    float pU = (id.z < size_-1) ? pressureTex[uint3(id.x, id.y, id.z+1)] : pC;

    float4 gradP = 0.5*float4(pR - pL, pT - pB, pU - pD, 0.0); float4 vOld = velocity;
    float4 vNew = vOld - gradP;

    
    
    velocityTexRes[id] = vNew;
    densityTexRes[id] = density;
    //temperatureTexRes[id] = temperature;
    pressureTexRes[id] = pressure;
    
    AllMemoryBarrier();
    
 

}