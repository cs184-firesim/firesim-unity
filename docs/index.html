<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Realistic Fire Simulation and Rendering</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
    <link rel="stylesheet" href="css/bulma.css">
    <link rel="stylesheet" href="css/styles.css">
  </head>
  <body>
    <section class="section">
        <div class="container">
            <h1 class="title">
            Realistic Fire Simulation and Rendering
            </h1>
            <h2 class="subtitle">
            Authors: Eric Ge, Debbie Liang, Ziyao Zhang
            </h2>
            <p class="content">
                In this project, we achieved real time simulation and rendering of fire effects in both 2D and 3D. Our implementation utilized Unity post processing and HLSL shaders as the programming platform, and we adopted popular techniques in noise generation, physical simulation and volumetric rendering. Our 2D fire is implemented with panning Voronoi noise and Perlin noise, while our 3D fire relies on a custom fluid-simulation and ray-marching procedure. We measured our rendering effects and performance on an NVIDIA 2060 graphics card and obtained near real-time results.
            </p>
            <div class="columns is-mobile is-centered has-text-centered">
                <div class="column is-one-quarter-tablet is-half-mobile">
                    <figure class="image">
                        <img src="images/2d-fire.gif">
                        <figcaption>Noise-based 2D Fire</figcaption>
                    </figure>
                </div>
                <div class="column is-one-quarter-tablet">
                    <figure class="image">
                        <img src="images/3d-fire.gif">
                        <figcaption>Voxel-based 3D Fire</figcaption>
                    </figure>
                </div>
            </div>
        </div>
    </section>
    <section class="section no-top-padding">
        <div class="container">
        <h1 class="title">
            Technical Approach
        </h1>
        <h2 class="title is-4">
            2D Fire
        </h2>
        <p>
            We multiplied Voronoi noise and Perlin noise textures and interpolated their product with a standard u-v texture. We then took Gaussian Blob samples to simulate the features of fire. Lastly, we applied a color gradient to give an orange color to the blob.
        </p>
        <figure class="image has-text-centered">
            <img src="images/nodegraph.PNG">
            <figcaption>Complete Node Graph</figcaption>
        </figure>
        <h2 class="title is-4">
            3D Fire
        </h2>
        <h3 class="subtitle">Simulation</h3>
        <p>
            We decided to use 3D textures to hold different attributes that describe a fire. In our simulation, we calculated the corresponding values for velocity, smoke density, temperature, and fuel level in each cell of a 3D voxelized grid.
            </br></br>
            We based our simulation off the Navier Stokes equation for fluid dynamics:

            $$\frac{\partial u}{\partial t} = -(u \cdot \nabla) u - \frac{1}{\rho} \nabla p + f$$

            In the formula, \(u\) is the velocity, \(p\) is the pressure, \(\rho\) is the density of the molecule mass, and \(f\) is the external force on molecules. The first term represents the advection, which is the velocity of a fluid that causes the fluid to transport objects, densities, and other quantities along with the flow. The term inside the parenthesis is the divergence, which represents the rate at which density exits the region. The second term simulates how pressure gathers and generates force and provides accelerations to the surrounding molecules.
            </br></br>
            For each time step, we compute the advection and divergence based on the interaction between neighboring voxels, and propagate the changes in temperature, pressure, and velocity correspondingly. We then update the values in each 3D texture and render the resulting volume to the screen with the rendering pipeline.
            </br></br>
            For the external force field of the Navier Stokes equation, we simulated both buoyant force and vorticity force using the following equations:

            $$f_{buoyancy} = \frac{Pmg}{R} (\frac{1}{T_0} - \frac{1}{T})z$$
            $$f_{vc} = \epsilon(\Psi \times \omega)\delta x$$
            $$\Psi = \frac{\eta}{|\eta|}$$
            $$\eta = \nabla |\omega|$$

            The buoyant force is influenced by temperature and density, and it changes the velocity of molecules to make the simulation more realistic. With a higher temperature, the molecules will rise with a larger velocity. The other force that we applied to our molecules is vorticity force. This force helps us restore some of the curling behavior of smoke that was lost due to the discrete nature of the simulation.
            </br></br>
            Below is the simulation pipeline that we used. It outputs the values in 3D Textures encoding.
        </p>
        <div class="columns is-mobile is-centered has-text-centered">
            <div class="column is-half-tablet is-full-mobile">
                <figure class="image">
                    <img src="images/pipeline.png">
                    <figcaption>Simulation Pipeline</figcaption>
                </figure>
            </div>
        </div>
        <h3 class="subtitle">Rendering</h3>
        <p>
            After implementing the simulation part, we gave the fire some orange color and rendered the result using HLSL render shader in Unity, injected into the pipeline via post processing. Instead of using ray-tracing technique mentioned in class, we used ray-marching technique to realize the effect that rays advance with time steps and restored the effect of rays meeting particles with different densities in further arithmetic calculation. The volumetric ray-marching shader takes in the Below is a schematic graph for Ray-Marching. It takes in the 3D Voxel Grids generated by the simulation stage and renders Smoke Density and Reaction coordinate to the screen.
            <br><br>
            Our fire consists of three components: a solid core, a bright border, and some smoke. For the smoke, we’ve used the Beer’s Law to create the exponential drop off effect, in-scattering to create the dark edges, and the Henyey-Greenstein Phase Function to create the silver lining.
        </p>
        <div class="columns is-mobile is-centered has-text-centered">
            <div class="column is-half-tablet is-full-mobile">
                <figure class="image">
                    <img src="images/raymarching.png">
                    <figcaption>Ray Marching</figcaption>
                </figure>
            </div>
        </div>
        <h3 class="subtitle">Special Effects</h3>
        <p>
            In order to make the fire appear more realistic, we also added an additional ember effect to the top of the flames. Ember effect are distinct spurts of burning particles that are cause by incompletely combusted fuel that are advected into the air. This special effect is integrated into our physical model by simulating a additional Voxel space of ember particles that are randomly generated at the bottom of the fire with Perlin noise and propelled upwards through advection. Our raymarching procedure detects these particles and add a small glowing aura around them to make them appear realistic.
        </p>
        <div class="columns is-mobile is-centered has-text-centered">
            <div class="column is-one-quarter-tablet is-full-mobile">
                <figure class="image">
                    <img src="images/ember.png">
                    <figcaption>Ember Close-up</figcaption>
                </figure>
            </div>
        </div>
        </div>
    </section>
    <section class="section no-top-padding">
        <div class="container">
        <h1 class="title">Results</h1>
        <p>
            We experimented our simulation and rendering procedure on an NVIDIA RTX 2060 graphics card and achieved real-time (60+ fps) results. We set our voxel grid size to 128*128*128. For our GPU kernels, we used 16*16*16 GPU blocks, each containing 512 threads.
        </p>
        </div>
    </section>
    <section class="section no-top-padding">
        <div class="container">
        <h1 class="title">Problems & Lessons Learned</h1>
        <p>
            The main difficulty of our implementation came from debugging the propagation of the attributes across timestamps. Unity is not designed to accommodate print debugging so we created a script in Python to calculate the values for a 2D fire simulation. It turned out that the values propagated as expected, which proved that our formula was correctly implemented. We then created a debugging shader, which fills in empty textures when the value that we are testing passes a certain threshold. With the debugging shader, we could easily visualize how the values advanced in our model.
            <br><br>
            Some static numerical values cannot be assigned in computing kernels directly. For example, our time step value remained to be zero when we tried to assign it to be a non-zero value in our computing kernel and stopped other values from propagating when time advances. The values of velocity and pressure remained to be zero for a long time and we didn’t know why. We found this bug with our debugging shader. We then explicitly declared these numerical values inside the C# driver file and passed into the computing kernels.
        </p>
        </div>
    </section>
    <section class="section no-top-padding">
        <div class="container">
        <h1 class="title">References</h1>
        <p>
            TODO
        </p>
        </div>
    </section>
  </body>
</html>